
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_auto_examples/1_basic/plot_1_data_prepration.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__auto_examples_1_basic_plot_1_data_prepration.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__auto_examples_1_basic_plot_1_data_prepration.py:


============================
1a. Getting started
============================
This tutorial will demonstrate how to setup a basic geological model for using with LoopStructural.

.. GENERATED FROM PYTHON SOURCE LINES 10-48

Implicit surface modelling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LoopStructural uses implicit surface representation to build upper and lower surfaces for geological horizons.
Implicit surface representation involves approximating an unknown function :math:`f(x,y,z)` where the function value
represents the distance from a reference horizon.
Geological surfaces can be represented by tracing isovalues of the scalar field.
The implicit function is approximated using numerical techniques to find a function that fits the observations.
There are two main approaches used in implicit modelling for approximating these implicit functions:

1. Data supported approximation using polynomial trend methods
2. Discrete approaches using a interpolation support and minimising the misfit to observations and a regularisation term.

The main interpolation approach used by LoopStructural is Discrete implicit modelling approaches where the geological observations
are combined with a regularisation term to find the best resulting surface.

There are two main interpolators that can be used:

1. Piecewise Linear interpolator - which uses a regular tetrahedron mesh with P1 finite elements
2. Finite difference interpolator - which uses a regular Cartesian grid with cubic elements using trilinear interpolation

Data types
~~~~~~~~~~
There are three constraints that can be added to the interpolator

1. Value constraints which set enforce :math:`f(x,y,z) = value`
2. Gradient constraints which set the interpolated gradient of the function to be orthogonal to an observed vector :math:`f'(x,y,z) \cdot v = 0`
3. Gradient norm constraints which set the partial derivative of the implicit function to be equal to the components of the observed normal vector.

GeologicalFeatures
~~~~~~~~~~~~~~~~~~
A typical geological model may contain multiple geological interfaces, including unconformities and faults.
Conformable surfaces can be represented by a single implicit function where different isosurfaces represent different horizons.

In LoopStructural an implicit function is encapsulated by a GeologicalFeature.
The GeologicalFeature represents an object within the model that can be evaluated at any location within the model area.




.. GENERATED FROM PYTHON SOURCE LINES 51-58

Define the model area
Origin = (0,0,0)
Maximum = (10,10,10)

Create a pointset representing two flat surfaces one at z = 1 with a value of 0 and one at z = 5 with a value of 1,
add some noise to make it interesting!


.. GENERATED FROM PYTHON SOURCE LINES 58-77

.. code-block:: Python

    import numpy as np
    from LoopStructural.utils import rng

    extent = np.zeros((3, 2))
    extent[:, 1] = 10

    x = np.linspace(0, 10, 10)
    y = np.linspace(0, 10, 10)

    xx, yy = np.meshgrid(x, y)
    zz = np.zeros_like(xx)
    zz[:] = 1 + rng.random(zz.shape)
    val = np.zeros_like(xx)
    val[:] = 0
    surface_1 = np.array([xx.flatten(), yy.flatten(), zz.flatten(), val.flatten()]).T
    zz[:] = 5 + rng.random(zz.shape)
    val[:] = 1
    surface_2 = np.array([xx.flatten(), yy.flatten(), zz.flatten(), val.flatten()]).T








.. GENERATED FROM PYTHON SOURCE LINES 78-92

Creating LoopStructural dataset
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LoopStructural uses pandas dataframes for importing and manipulating the data used for geological
modelling. There are key headers that are used to interpret the numerical data into the geological
interpolators

* :code:`X,Y,Z` represent the location of the observation
* :code:`val` represents the value constraints
* :code:`tx,ty,tz` represent the components of a vector which should be orthogonal to the interpolated function
* :code:`gx,gy,gz` represent a constraint where the interpolated scalar field is parallel to this vector
* :code:`nx,ny,nz` represent a constraint which set the partial derivatives of the function.
* :code:`feature_name` assigns which geologicalfeature the observations control
**Note** for the interpolator to solve there needs to be two unique values or a norm constraint
for the interpolator to be able to find a solution.

.. GENERATED FROM PYTHON SOURCE LINES 92-99

.. code-block:: Python


    import pandas as pd

    data = pd.DataFrame(np.vstack([surface_1, surface_2]), columns=["X", "Y", "Z", "val"])
    data["feature_name"] = "conformable"
    data.head()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
          <th>val</th>
          <th>feature_name</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.000000</td>
          <td>0.0</td>
          <td>1.003456</td>
          <td>0.0</td>
          <td>conformable</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1.111111</td>
          <td>0.0</td>
          <td>1.588114</td>
          <td>0.0</td>
          <td>conformable</td>
        </tr>
        <tr>
          <th>2</th>
          <td>2.222222</td>
          <td>0.0</td>
          <td>1.334220</td>
          <td>0.0</td>
          <td>conformable</td>
        </tr>
        <tr>
          <th>3</th>
          <td>3.333333</td>
          <td>0.0</td>
          <td>1.203579</td>
          <td>0.0</td>
          <td>conformable</td>
        </tr>
        <tr>
          <th>4</th>
          <td>4.444444</td>
          <td>0.0</td>
          <td>1.634137</td>
          <td>0.0</td>
          <td>conformable</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 100-107

Creating a GeologicalModel
~~~~~~~~~~~~~~~~~~~~~~~~~~~
The GeologicalModel is the main entry point into LoopStructural which manages the model domain,
setting up the interpolators, unconformities, faults etc.
To create a GeologicalModel we need to define the extent of the model with an origin vector and a maximum vector.
The pandas dataframe that contains the model data need to be linked to the geological model.


.. GENERATED FROM PYTHON SOURCE LINES 107-113

.. code-block:: Python


    from LoopStructural import GeologicalModel

    model = GeologicalModel(extent[:, 0], extent[:, 1])
    model.set_model_data(data)








.. GENERATED FROM PYTHON SOURCE LINES 114-118

Adding a conformable foliation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We can create a geological feature using the create_and_add_foliation method.
This returns a To build a scalar field representing the

.. GENERATED FROM PYTHON SOURCE LINES 118-121

.. code-block:: Python


    conformable_feature = model.create_and_add_foliation("conformable")








.. GENERATED FROM PYTHON SOURCE LINES 122-135

Visualising a 2-D section
~~~~~~~~~~~~~~~~~~~~~~~~~
Geological feature can be evaluated:
* for the scalar field value at a location
* for the gradient of the scalar field at a location
To evaluate a model feature (scalar value or gradient) use the:
:code:`model.evaluate_feature_value(feature_name, locations)` or
:code:`model.evaluate_feature_gradient(feature_name, locations)`
Where the feature_name is the string naming the feature and locations is a numpy array of
xyz coordinates.

In the following example we will use matplotlib to visualise these results however, the
next tutorial will show how to use the lavavu visualisation model.

.. GENERATED FROM PYTHON SOURCE LINES 135-169

.. code-block:: Python



    import matplotlib.pyplot as plt

    # X section
    y = np.linspace(0, 10, 100)
    z = np.linspace(0, 10, 100)

    yy, zz = np.meshgrid(y, z)
    xx = np.zeros_like(yy)
    xx[:] = 5

    vals = model.evaluate_feature_value(
        "conformable", np.array([xx.flatten(), yy.flatten(), zz.flatten()]).T
    )
    fig, ax = plt.subplots(1, 2, figsize=(20, 10))
    ax[0].contourf(vals.reshape((100, 100)), extent=(0, 10, 0, 10))
    ax[0].contour(vals.reshape((100, 100)), [0, 1], extent=(0, 10, 0, 10))

    # Y section
    x = np.linspace(0, 10, 100)
    z = np.linspace(0, 10, 100)

    xx, zz = np.meshgrid(x, z)
    yy = np.zeros_like(xx)
    yy[:] = 5

    vals = model.evaluate_feature_value(
        "conformable", np.array([xx.flatten(), yy.flatten(), zz.flatten()]).T
    )
    ax[1].contourf(vals.reshape((100, 100)), extent=(0, 10, 0, 10))
    ax[1].contour(vals.reshape((100, 100)), [0, 1], extent=(0, 10, 0, 10))

    plt.show()



.. image-sg:: /_auto_examples/1_basic/images/sphx_glr_plot_1_data_prepration_001.png
   :alt: plot 1 data prepration
   :srcset: /_auto_examples/1_basic/images/sphx_glr_plot_1_data_prepration_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.305 seconds)


.. _sphx_glr_download__auto_examples_1_basic_plot_1_data_prepration.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_1_data_prepration.ipynb <plot_1_data_prepration.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_1_data_prepration.py <plot_1_data_prepration.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_1_data_prepration.zip <plot_1_data_prepration.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
